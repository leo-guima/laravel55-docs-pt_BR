# Validação

- Introdução
- Começo rápido
  - Definindo as rotas
  - Criando o controller
  - Escrevendo a lógica de validação
  - Exibindo os erros de validação
  - Uma nota sobre campos opcionais
- Validação de request de formulário
  - Criando request de formulário
  - Autorizando requests de formulário
  - Personalizando as mensagens de erro
- Criando manualmente os Validators
  - Redirecionamento automático
  - Named Error Bags
  - Gancho Após Validação
- Trabalhando com mensagens de erro
  - Mensagens de erro personalizadas
- Regras de validação disponíveis
- Adicionando regras condicionais
- Validando Arrays
- Regras de validação personalizadas
  - Usando Objetos de Regra
  - Usando extensões




## Introdução

O Laravel fornece várias abordagens diferentes para validar os dados recebidos do seu aplicativo. Por padrão, a classe controller base do Laravel usa uma característica `ValidatesRequests` que fornece um método conveniente para validar a solicitação HTTP recebida com uma variedade de poderosas regras de validação.



## Começo rápido

Para saber mais sobre os poderosos recursos de validação do Laravel, vejamos um exemplo completo de validação de um formulário e exibir as mensagens de erro de volta para o usuário.

### Definindo as rotas

Primeiro, vamos assumir que temos as seguintes rotas definidas em nosso arquivo `routes/web.php`:

```php
Route::get('post/create', ' PostController@create '); 

Route::post('post', ' PostController@store '); 
```

A rota `GET` exibirá um formulário para o usuário criar uma nova postagem no blog, enquanto a rota `POST` irá armazenar a nova postagem do blog no banco de dados.

### Criando o controller

Em seguida, vamos dar uma olhada em um controller simples que lida com essas rotas. Deixaremos o método `store` vazio por enquanto:

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Http\Controllers\Controller;

class PostController extends Controller
{
    /**
     * Show the form to create a new blog post.
     *
     * @return Response
     */
    public function create()
    {
        return view('post.create');
    }

    /**
     * Store a new blog post.
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        // Validate and store the blog post...
    }
}
```

### Escrevendo a lógica de validação

Agora, estamos prontos para preencher o nosso método `store` com a lógica para validar a nova postagem do blog. Para fazer isso, usaremos o método `validate` fornecido pelo objeto `Illuminate\Http\Request`. Se as regras de validação forem aprovadas, seu código continuará executando normalmente; no entanto, se a validação falhar, uma exceção será lançada e a resposta de erro correta será automaticamente enviada ao usuário. No caso de uma solicitação HTTP tradicional, uma resposta de redirecionamento será gerada, enquanto uma resposta JSON será enviada para solicitações AJAX.

Para obter uma melhor compreensão do método `validate`, vamos voltar para o método da `store`:

```php
/**
 * Store a new blog post.
 *
 * @param  Request  $request
 * @return Response
 */
public function store(Request $request)
{
    $validatedData = $request->validate([
        'title' => 'required|unique:posts|max:255',
        'body' => 'required',
    ]);

    // The blog post is valid...
}
```

Como você pode ver, simplesmente passamos as regras de validação desejadas para o método `validate`. Novamente, se a validação falhar, a resposta adequada será gerada automaticamente. Se a validação for passada, nosso controller continuará executando normalmente.

#### Parando na primeira falha de validação

Às vezes, você pode querer parar de executar as regras de validação em um atributo após a primeira falha de validação. Para fazer isso, atribua a regra `bail` ao atributo:

```php
$request->validate([
    'title' => 'bail|required|unique:posts|max:255',
    'body' => 'required',
]);
```

Neste exemplo, se a regra `unique` no atributo `title` falhar, a regra `max` não será verificada. As regras serão validadas na ordem em que são atribuídas.

#### Uma nota sobre atributos aninhados

Se sua solicitação HTTP contiver parâmetros "aninhados", você pode especificá-los em suas regras de validação usando a sintaxe "ponto":

```php
$request->validate([
    'title' => 'required|unique:posts|max:255',
    'author.name' => 'required',
    'author.description' => 'required',
]);
```

### Exibindo os erros de validação

Então, e se os parâmetros de solicitação recebidos não passarem as regras de validação fornecidas? Como mencionado anteriormente, o Laravel redirecionará automaticamente o usuário de volta para sua localização anterior. Além disso, todos os erros de validação serão automaticamente [exibidos na sessão](/9.Sessao.md).

Mais uma vez, note que não precisamos ligar explicitamente as mensagens de erro à vew em nossa rota `GET`. Isso ocorre porque o Laravel verificará se há erros nos dados da sessão e os amarrará automaticamente à view se eles estiverem disponíveis. A variável `$errors` será uma instância do `Illuminate\Support\MessageBag`. 

> **Dica:** A variável `$errors` é vinculada à view pelo `Illuminate\View\Middleware\ShareErrorsFromSession`, que é fornecido pelo grupo de middleware da `web` . **Quando este middleware é aplicado, uma variável $errors estará sempre disponível nas suas views**, permitindo que você assuma convenientemente a variável `$errors` sempre definida e pode ser usada com segurança.

Então, no nosso exemplo, o usuário será redirecionado para o método `create` do nosso controller quando a validação falhar, permitindo-nos exibir as mensagens de erro na visualização:

```php+HTML
<!-- /resources/views/post/create.blade.php -->

<h1>Create Post</h1>

@if ($errors->any())
    <div class="alert alert-danger">
        <ul>
            @foreach ($errors->all() as $error)
                <li>{{ $error }}</li>
            @endforeach
        </ul>
    </div>
@endif

<!-- Create Post Form -->
```

### Uma nota sobre campos opcionais

Por padrão, o Laravel inclui o middleware `TrimStrings` e `ConvertEmptyStringsToNull` na pilha de middleware global da sua aplicação. Esses middleware são listados na pilha pela classe `App\Http\Kernel`. Devido a isso, muitas vezes você precisará marcar seus campos de solicitação "opcionais" como `nullable` se você não quiser que o validador considere inválidos os valores nulos. Por exemplo:

```php
$request->validate([
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
    'publish_at' => 'nullable|date',
]);
```

Neste exemplo, estamos especificando que o campo `publish_at` pode ser `null` ou uma representação de data válida. Se o modificador `nullable` não for adicionado à definição da regra, o validador consideraria `null` uma data inválida.

#### AJAX Requests & Validação

Neste exemplo, usamos um formulário tradicional para enviar dados para o aplicativo. No entanto, muitas aplicações usam requests AJAX. Ao usar o método `validate` durante uma solicitação AJAX, o Laravel não gerará uma resposta de redirecionamento. Em vez disso, o Laravel gera uma resposta JSON contendo todos os erros de validação. Essa resposta JSON será enviada com um código de status HTTP 422.

## Validação de request de formulário

### Criando request de formulário

Para cenários de validação mais complexos, você pode querer criar um "request de formulário". Os requests de formulário são classes de solicitação personalizadas que contêm lógica de validação. Para criar uma classe de solicitação de formulário, use o comando `make:request` do Artisan CLI:

```sh
php artisan make:request StoreBlogPost
```

A classe gerada será colocada no diretório `app/Http/Requests`. Se esse diretório não existir, ele será criado quando você executar o comando `make:request`. Vamos adicionar algumas regras de validação ao método  `rules` :

```php
/**
 * Get the validation rules that apply to the request.
 *
 * @return array
 */
public function rules()
{
    return [
        'title' => 'required|unique:posts|max:255',
        'body' => 'required',
    ];
}
```

Então, como as regras de validação são avaliadas? Tudo o que você precisa fazer é digitar a solicitação no método do seu controller. A solicitação de formulário recebida é validada antes que o método do controller seja chamado, o que significa que você não precisa desordenar seu controller com qualquer lógica de validação:

```php
/**
 * Store the incoming blog post.
 *
 * @param  StoreBlogPost  $request
 * @return Response
 */
public function store(StoreBlogPost $request)
{
    // The incoming request is valid...
}
```

Se a validação falhar, uma resposta de redirecionamento será gerada para enviar o usuário de volta ao seu local anterior. Os erros também serão exibidos na sessão para que eles estejam disponíveis para exibição. Se o pedido fosse uma solicitação AJAX, uma resposta HTTP com um código de status 422 será retornada ao usuário, incluindo uma representação JSON dos erros de validação.

#### Adicionando ganchos posteriores para request de formulário

Se você quiser adicionar um gancho posterior a uma solicitação de formulário, você pode usar o método `withValidator`. Este método recebe o validador totalmente construído, permitindo que você chame qualquer um dos seus métodos antes que as regras de validação sejam realmente avaliadas:

```php
/**
 * Configure the validator instance.
 *
 * @param  \Illuminate\Validation\Validator  $validator
 * @return void
 */
public function withValidator($validator)
{
    $validator->after(function ($validator) {
        if ($this->somethingElseIsInvalid()) {
            $validator->errors()->add('field', 'Something is wrong with this field!');
        }
    });
}
```

### Autorizando requests de formulário

A classe de solicitação de formulário também contém um método `authorize`. Dentro deste método, você pode verificar se o usuário autenticado realmente tem autoridade para atualizar um determinado recurso. Por exemplo, você pode determinar se um usuário realmente possui um comentário de blog que está tentando atualizar:

```php
/**
 * Determine if the user is authorized to make this request.
 *
 * @return bool
 */
public function authorize()
{
    $comment = Comment::find($this->route('comment'));

    return $comment && $this->user()->can('update', $comment);
}
```

Uma vez que todos os pedidos de formulário estendem a classe base Request do Laravel, podemos usar o método `user` para acessar o usuário atualmente autenticado. Observe também a chamada para o método  `route` no exemplo acima. Este método concede acesso aos parâmetros URI definidos na rota que está sendo chamada, como o parâmetro `{comment}` no exemplo abaixo:

```php
Route::post('comment/{comment}'); 
```

Se o método `authorize` retornar `false` , uma resposta HTTP com um código de status 403 será automaticamente retornada e seu método de controller não será executado.

Se você planeja ter lógica de autorização em outra parte do seu aplicativo, basta retornar `true` no método `authorize`:

```php
/**
 * Determine if the user is authorized to make this request.
 *
 * @return bool
 */
public function authorize()
{
    return true;
}
```



### Personalizando as mensagens de erro

Você pode personalizar as mensagens de erro usadas pelo request do formulário, substituindo o método `messages`. Este método deve retornar uma matriz de pares de atributos / regras e suas mensagens de erro correspondentes:

```php
/**
 * Get the error messages for the defined validation rules.
 *
 * @return array
 */
public function messages()
{
    return [
        'title.required' => 'A title is required',
        'body.required'  => 'A message is required',
    ];
}
```



## Criando os Validators manualmente

Se você não quiser usar o método `validate` no request, você pode criar uma instância do validador manualmente usando a façade `Validator`. O método `make` na façade gera uma nova instância de validação:

```php
<?php

namespace App\Http\Controllers;

use Validator;
use Illuminate\Http\Request;
use App\Http\Controllers\Controller;

class PostController extends Controller
{
    /**
     * Store a new blog post.
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        $validator = Validator::make($request->all(), [
            'title' => 'required|unique:posts|max:255',
            'body' => 'required',
        ]);

        if ($validator->fails()) {
            return redirect('post/create')
                        ->withErrors($validator)
                        ->withInput();
        }

        // Store the blog post...
    }
}
```

O primeiro argumento passado para o método `make` é o dado em validação. O segundo argumento é as regras de validação que devem ser aplicadas aos dados.

Depois de verificar se a validação da solicitação falhou, você pode usar o método `withErrors` para enviar as mensagens de erro para a sessão. Ao usar este método, a variável `$errors` será automaticamente compartilhada com suas views após o redirecionamento, permitindo que você as exiba facilmente de volta para o usuário. O método `withErrors` aceita um validador, um `MessageBag` ou uma `array` PHP.

### Redirecionamento automático

Se você quiser criar uma instância de validação manualmente, mas ainda aproveitar o redirecionamento automático oferecido pelo método `validate`, você pode chamar o método `validate` em uma instância de validador existente. Se a validação falhar, o usuário será redirecionado automaticamente ou, no caso de uma solicitação AJAX, uma resposta JSON será retornada:

```php
Validator::make($request->all(), [
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
])->validate();
```

### Named Error Bags

Se você tiver vários formulários em uma única página, talvez queira nomear o `MessageBag` de erros, permitindo que você recupere as mensagens de erro para um formulário específico. Basta passar um nome como o segundo argumento para `withErrors` :

```php
eturn redirect('register')
            ->withErrors($validator, 'login');
```

Você pode acessar a instância `MessageBag` nomeada da variável `$errors` :

```php
{{ $errors->login->first('email') }} 
```

### Gancho Após Validação

O validador também permite que você anexe retorno de chamada para ser executado após a validação ser concluída. Isso permite que você realize facilmente mais validação e até adicione mais mensagens de erro à coleção de mensagens. Para começar, use o método `after` em uma instância de validador:

```php
$validator = Validator::make(...);

$validator->after(function ($validator) {
    if ($this->somethingElseIsInvalid()) {
        $validator->errors()->add('field', 'Something is wrong with this field!');
    }
});

if ($validator->fails()) {
    //
}
```



## Trabalhando com mensagens de erro

Depois de chamar o método `errors` em uma instância do `Validator`, você receberá uma instância `Illuminate\Support\MessageBag`, que possui uma variedade de métodos convenientes para trabalhar com mensagens de erro. A variável `$errors` que está automaticamente disponível para todas as visualizações também é uma instância da classe `MessageBag`.

#### Recuperando a primeira mensagem de erro para um campo

Para recuperar a primeira mensagem de erro para um determinado campo, use o `first` método:

```php
$errors = $validator->errors(); 

echo $errors->first('email'); 
```

#### Recuperando todas as mensagens de erro para um campo

Se você precisar recuperar uma matriz de todas as mensagens para um determinado campo, use o método `get` :

```php
foreach ($errors->get('email') as $message) {
    //
}
```

Se você estiver validando um campo de formulário de matriz, você pode recuperar todas as mensagens para cada um dos elementos da matriz usando o caractere `*` :

```php
foreach ($errors->get('attachments.*') as $message) {
    //
}
```

#### Recuperando todas as mensagens de erro para todos os campos

Para recuperar uma matriz de todas as mensagens para todos os campos, use `all`:

```php
foreach ($errors->all() as $message) {
    //
}
```

#### Determinando se existem mensagens para um campo

O método `has` pode ser usado para determinar se existem mensagens de erro para um determinado campo:

```php
if ($errors->has('email')) {
    //
}
```

### Mensagens de erro personalizadas

Se necessário, você pode usar mensagens de erro personalizadas para validação em vez dos padrões. Existem várias maneiras de especificar mensagens personalizadas. Primeiro, você pode passar as mensagens personalizadas como o terceiro argumento para o método `Validator::make`:

```php
$messages = [
    'required' => 'The :attribute field is required.',
];

$validator = Validator::make($input, $rules, $messages);
```

Neste exemplo, o `:attribute` será substituído pelo nome real do campo em validação. Você também pode utilizar outros titulos em mensagens de validação. Por exemplo:

```php
$messages = [
    'same'    => 'The :attribute and :other must match.',
    'size'    => 'The :attribute must be exactly :size.',
    'between' => 'The :attribute value :input is not between :min - :max.',
    'in'      => 'The :attribute must be one of the following types: :values',
];
```

#### Especificando uma mensagem personalizada para um atributo dado

Às vezes, você pode querer especificar mensagens de erro personalizadas somente para um campo específico. Você pode fazê-lo usando a notação "ponto". Especifique primeiro o nome do atributo, seguido da regra:

```php
$messages = [
    'email.required' => 'We need to know your e-mail address!',
];
```

#### Especificando mensagens personalizadas em arquivos de idioma

Na maioria dos casos, você provavelmente especificará suas mensagens personalizadas em um arquivo de idioma em vez de passá-las diretamente para o `Validator` . Para fazer isso, adicione suas mensagens à matriz `custom` no arquivo de idioma `resources/lang/xx/validation.php` .

```php
'custom' => [
    'email' => [
        'required' => 'We need to know your e-mail address!',
    ],
],
```

#### Especificando atributos personalizados em arquivos de idioma

Se você quiser que a porção de `:attribute` de sua mensagem de validação seja substituída por um nome de atributo personalizado, você pode especificar o nome personalizado na matriz de `attributes` de seus `resources/lang/xx/validation.php` arquivo de idioma:

```php
'attributes' => [
    'email' => 'email address',
],
```

## [Regras de validação disponíveis](https://laravel.com/docs/5.5/validation#available-validation-rules)

Abaixo está uma lista de todas as regras de validação disponíveis e sua função:

#### accepted

O campo em validação deve ser *yes*, *on*, *1* ou *true* . Isso é útil para validar a aceitação de "Termos de Serviço".

#### active_url

O campo em validação deve ter um registro A ou AAAA válido de acordo com a função PHP `dns_get_record`.

#### after:*data*

O campo em validação deve ser um valor após uma determinada data. As datas serão passadas para a função PHP `strtotime`:

```php
'start_date' => 'required|date|after:tomorrow' 
```

Em vez de passar uma sequência de data a ser avaliada pelo `strtotime` , você pode especificar outro campo para comparar com a data:

```php
'finish_date' => 'required|date|after:start_date' 
```

#### after_or_equal:*data*

O campo em validação deve ser um valor após ou igual à data determinada. 

#### alpha

O campo sob validação deve ser inteiramente caracteres alfabéticos.

#### alpha_dash

O campo em validação pode ter caracteres alfanuméricos, bem como traços e sublinhados.

#### alpha_num

O campo sob validação deve ser completamente caracteres alfanuméricos.

#### array

O campo em validação deve ser uma `array` PHP.

#### before:*data*

O campo em validação deve ser um valor anterior à data determinada. As datas serão passadas para a função PHP `strtotime` .

#### before_or_equal:*data*

O campo em validação deve ser um valor anterior ou igual à data determinada. As datas serão passadas para a função PHP `strtotime` .

#### between:*min*,*max*

O campo em validação deve ter um tamanho entre o valor *mínimo* e o *máximo* especificado. Strings, numerais, arrays e arquivos são avaliados da mesma forma que a regra `size`.

#### boolean

O campo em validação deve poder ser lançado como booleano. A entrada aceita é `true` , `false` , `1`, `0` , `"1"` e `"0"` .

#### confirmed

O campo em validação deve ser um campo correspondente a `foo_confirmation` . Por exemplo, se o campo sob validação for uma `password`, um campo correspondente de `password_confirmation` deve estar presente na entrada.

#### date

O campo sob validação deve ser uma data válida de acordo com a função PHP `strtotime` .

#### date_equals:*data*

O campo em validação deve ser igual à data determinada. As datas serão passadas para a função PHP `strtotime` .

#### date_format:*formato*

O campo em validação deve corresponder ao *formato* fornecido. Você deve usar `date` ou `date_format` ao validar um campo, e não ambos.

#### different:*campo*

O campo em validação deve ter um valor diferente do *campo* .

#### digits:*valor*

O campo sob validação deve ser *numérico* e deve ter um comprimento exato de *valor* .

#### digits_between:*min*,*max*

O campo em validação deve ter um comprimento entre o valor *minimo* e *máximo* .

#### dimensions

O arquivo em validação deve ser uma imagem que atenda às restrições de dimensão conforme especificado pelos parâmetros da regra:

```php
'avatar' => 'dimensions:min_width=100,min_height=200' 
```

As restrições disponíveis são: *min_width* , *max_width* , *min_height* , *max_height* , *width* , *height* , *ratio*.

Uma restrição de *ratio* deve ser representada como largura dividida por altura. Isso pode ser especificado por uma declaração como `3/2` ou um flutuador como `1.5` :

```php
'avatar' => 'dimensions:ratio=3/2' 
```

Uma vez que esta regra exige vários argumentos, você pode usar o método `Rule::dimensions` para construir fluentemente a regra:

```php
use Illuminate\Validation\Rule;

Validator::make($data, [
    'avatar' => [
        'required',
        Rule::dimensions()->maxWidth(1000)->maxHeight(500)->ratio(3 / 2),
    ],
]);
```

#### distinct

Ao trabalhar com arrays, o campo em validação não deve ter valores duplicados.

```php
'foo.*.id' => 'distinct' 
```

#### email

O campo em validação deve ser formatado como um endereço de e-mail.

#### exists:*tabela*,*coluna*

O campo em validação deve existir em uma determinada tabela de banco de dados.

#### Uso básico da regra existente

```php
'state' => 'exists:states' 
```

#### Especificando um nome de coluna personalizado

```php
'state' => 'exists:states,abbreviation' 
```

Ocasionalmente, você precisará especificar uma conexão de banco de dados específica a ser usada para a consulta `exists` . Você pode fazer isso, prependendo o nome da conexão para o nome da tabela usando a sintaxe "ponto":

```php
'email' => 'exists:connection.staff,email' 
```

Se você quiser personalizar a consulta executada pela regra de validação, você pode usar a classe `Rule` para definir com fluência a regra. Neste exemplo, também especificaremos as regras de validação como uma matriz em vez de usar o `|` caráter para delimitá-los:

```php
use Illuminate\Validation\Rule;

Validator::make($data, [
    'email' => [
        'required',
        Rule::exists('staff')->where(function ($query) {
            $query->where('account_id', 1);
        }),
    ],
]);
```

#### file

O campo sob validação deve ser um arquivo carregado com sucesso.

#### filled

O campo em validação não deve estar vazio quando estiver presente.

#### image

O arquivo em validação deve ser uma imagem (jpeg, png, bmp, gif ou svg)

#### in:*foo*,*bar*,...

O campo em validação deve ser incluído na lista de valores. Uma vez que esta regra geralmente exige que você `imploda` uma matriz, o método `Rule::in` pode ser usado para construir fluentemente a regra:

```php
use Illuminate\Validation\Rule;

Validator::make($data, [
    'zones' => [
        'required',
        Rule::in(['first-zone', 'second-zone']),
    ],
]);
```

#### in_array:*outro_campo*

O campo em validação deve existir nos valores de outro campo.

#### integer

O campo em validação deve ser um número inteiro.

#### ip

O campo em validação deve ser um endereço IP.

#### ipv4

O campo em validação deve ser um endereço IPv4.

#### ipv6

O campo em validação deve ser um endereço IPv6.

#### json

O campo em validação deve ser uma string JSON válida.

#### max:*valor*

O campo em validação deve ser inferior ou igual a um *valor* máximo. Strings, numerais, arrays e arquivos são avaliados da mesma forma que a regra `size`.

#### mimetypes:*text/plain*,...

O arquivo em validação deve corresponder a um dos tipos MIME fornecidos:

```php
'video' => 'mimetypes:video/avi,video/mpeg,video/quicktime' 
```

Para determinar o tipo MIME do arquivo carregado, o conteúdo do arquivo será lido e a estrutura tentará adivinhar o tipo MIME, que pode ser diferente do tipo MIME fornecido pelo cliente.

#### mimes:*foo*,*bar*,...

O arquivo em validação deve ter um tipo MIME correspondente a uma das extensões listadas.

#### Uso básico da regra MIME

```php
'photo' => 'mimes:jpeg,bmp,png' 
```

Mesmo que você precise especificar as extensões, esta regra realmente valida o tipo MIME do arquivo, lendo o conteúdo do arquivo e adivinhando seu tipo MIME.

Uma listagem completa de tipos MIME e suas extensões correspondentes podem ser encontradas no seguinte local: [https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types](https://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types)

#### min:*valor*

O campo em validação deve ter um *valor* mínimo. Strings, numerais, arrays e arquivos são avaliados da mesma forma que a regra`size` .

#### nullable

O campo em validação pode ser `null`. Isso é particularmente útil ao validar tipos primitivo, como strings e inteiros que podem conter valores `null`.

#### not_in:*foo*,*bar*,...

O campo em validação não deve ser incluído na lista de valores. O método `Rule::notIn` pode ser usado para construir fluentemente a regra:

```php
use Illuminate\Validation\Rule;

Validator::make($data, [
    'toppings' => [
        'required',
        Rule::notIn(['sprinkles', 'cherries']),
    ],
]);
```

#### numeric

O campo em validação deve ser numérico.

#### present

O campo sob validação deve estar presente nos dados de entrada, mas pode estar vazio.

#### regex:*padrão*

O campo em validação deve corresponder à expressão regular dada.

**Nota:** Ao usar o padrão `regex` , pode ser necessário especificar regras em uma matriz ao invés de usar delimitadores pipe, especialmente se a expressão regular contiver um caractere pipe.

#### required

O campo em validação deve estar presente nos dados de entrada e não está vazio. Um campo é considerado "vazio" se uma das seguintes condições for verdadeira:

- O valor é `null` .
- O valor é uma string vazia.
- O valor é uma matriz vazia ou um objeto `Countable` vazio.
- O valor é um arquivo carregado sem caminho.

#### required_if:*outro_campo*,*valor*,...

O campo em validação deve estar presente e não vazio se o *outro_campo* for igual a qualquer *valor*.

#### required_unless:*outro_campo*,*valor*,...

O campo em validação deve estar presente e não vazio, a menos que o *outro_campo* seja igual a qualquer *valor*.

#### required_with:*foo*,*bar*,...

O campo em validação deve estar presente e não vazio *somente se* algum dos outros campos especificados estiver presente.

#### required_with_all:*foo*,*bar*,...

O campo sob validação deve estar presente e não vazio *somente se* todos os outros campos especificados estiverem presentes.

#### required_without:*foo*,*bar*,...

O campo em validação deve estar presente e não está vazio *somente quando* qualquer um dos outros campos especificados não estiverem presentes.

#### required_without_all:*foo*,*bar*,...

O campo em validação deve estar presente e não vazio *somente quando* todos os outros campos especificados não estiverem presentes.

#### same:*campo*

O *campo* especificado deve corresponder ao campo em validação.

#### size:*valor*

O campo em validação deve ter um tamanho correspondente ao *valor* dado. Para dados de string, o *valor* corresponde ao número de caracteres. Para dados numéricos, o *valor* corresponde a um determinado número inteiro. Para uma matriz, o *tamanho* corresponde à `count` da matriz. Para arquivos, o *tamanho* corresponde ao tamanho do arquivo em kilobytes.

#### string

O campo em validação deve ser uma string. Se você quiser permitir que o campo também seja `null`, você deve atribuir a regra `nullable` ao campo.

#### timezone

O campo sob validação deve ser um identificador de timezone válido de acordo com a função `timezone_identifiers_list` do PHP.

#### unique:*tabela*,*coluna*,*exceto*,*idColuna*

O campo em validação deve ser exclusivo em uma determinada tabela de banco de dados. Se a opção da `column` não for especificada, o nome do campo será usado.

**Especificando um nome de coluna personalizado:**

```php
'email' => 'unique:users,email_address' 
```

**Conexão de banco de dados personalizada**

Ocasionalmente, talvez seja necessário configurar uma conexão personalizada para consultas de banco de dados feitas pelo Validator. Como visto acima, a configuração `unique:users` como uma regra de validação usará a conexão padrão do banco de dados para consultar o banco de dados. Para substituir isso, especifique a conexão e o nome da tabela usando a sintaxe "ponto":

```php
'email' => 'unique:connection.users,email_address' 
```

**Forçando uma Regra Única para Ignorar uma Identificação Dada:**

Às vezes, você pode querer ignorar uma determinada ID durante a verificação exclusiva. Por exemplo, considere uma tela de "atualização de perfil" que inclua o nome do usuário, o endereço de e-mail e a localização. Claro, você quer verificar se o endereço de e-mail é único. No entanto, se o usuário apenas alterar o campo de nome e não o campo de e-mail, você não deseja que um erro de validação seja lançado porque o usuário já é o proprietário do endereço de e-mail.

Para instruir o validador a ignorar a ID do usuário, usaremos a classe `Rule` para definir com fluência a regra. Neste exemplo, também especificaremos as regras de validação como uma matriz em vez de usar o caractere `|`  para delimitar as regras:

```php
use Illuminate\Validation\Rule;

Validator::make($data, [
    'email' => [
        'required',
        Rule::unique('users')->ignore($user->id),
    ],
]);
```

Se sua tabela usa um nome de coluna de chave primária diferente de `id`, você pode especificar o nome da coluna ao chamar o método `ignore`:

```php
'email' => Rule::unique('users')->ignore($user->id, 'user_id') 
```

**Adicionando outras cláusulas adicionais:**

Você também pode especificar restrições de consulta adicionais personalizando a consulta usando o método `where`. Por exemplo, vamos adicionar uma restrição que verifica se o `account_id` é `1` :

```php
'email' => Rule::unique('users')->where(function ($query) {
    return $query->where('account_id', 1);
})

url
```

#### url

O campo em validação deve ser um URL válido.



## Adicionando regras condicionais

#### Validando quando presente

Em algumas situações, você pode querer executar verificações de validação em um campo **somente** se esse campo estiver presente na matriz de entrada. Para realizar isso rapidamente, adicione a regra `sometimes` à sua lista de regras:

```php
$v = Validator::make($data, [ 
  	'email' => 'sometimes|required|email', 
]); 
```

No exemplo acima, o campo de `email` só será validado se estiver presente na matriz `$data`.

> **Dica:** Se você está tentando validar um campo que sempre deve estar presente, mas pode estar vazio, confira a nota em campos opcionais

#### Validação condicional complexa

Às vezes, você pode querer adicionar regras de validação com base em lógica condicional mais complexa. Por exemplo, você pode querer exigir um determinado campo somente se outro campo tiver um valor maior do que 100. Ou, você pode precisar de dois campos para ter um determinado valor somente quando outro campo estiver presente. Adicionar essas regras de validação não precisa ser uma dor de cabeça. Primeiro, crie uma instância do `Validator` com suas *regras estáticas* que nunca mudam:

```php
$v = Validator::make($data, [ 
  	'email' => 'required|email', 
  	'games' => 'required|numeric', 
]); 
```

Vamos assumir que nossa aplicação web é para colecionadores de jogos. Se um colecionador de jogos se inscrever com nosso aplicativo e eles possuem mais de 100 jogos, queremos que eles explicem por que eles possuem tantos jogos. Por exemplo, talvez eles tenham uma loja de revenda de jogos, ou talvez simplesmente gostem de colecionar. Para adicionar condicionalmente esse requisito, podemos usar o método `sometimes` na instância do `Validator` .

```php
$v->sometimes('reason', 'required|max:500', function ($input) {
    return $input->games >= 100;
});
```

O primeiro argumento passado ao método `sometimes` é o nome do campo que estamos condicionalmente validando. O segundo argumento é as regras que queremos adicionar. Se o `Closure` passado como o terceiro argumento retornar `true` , as regras serão adicionadas. Este método torna fácil demais construir validações condicionais complexas. Você pode até adicionar validações condicionais para vários campos ao mesmo tempo:

```php
$v->sometimes(['reason', 'cost'], 'required', function ($input) {
    return $input->games >= 100;
});
```

> **Dica:** O parâmetro `$input` passado para o seu `Closure` será uma instância do `Illuminate\Support\Fluent` e pode ser usado para acessar seus inputs e arquivos.



## Validando Arrays

A validação de campos de entrada de formulário baseado em matriz não precisa ser uma dor. Você pode usar "notação de pontos" para validar atributos dentro de uma matriz. Por exemplo, se a solicitação HTTP recebida contiver um campo `photos[profile]` , você pode validá-lo assim:

```php
$validator = Validator::make($request->all(), [
    'photos.profile' => 'required|image',
]);
```

Você também pode validar cada elemento de uma matriz. Por exemplo, para validar que cada e-mail em um determinado campo de entrada de matriz é exclusivo, você pode fazer o seguinte:

```php
$validator = Validator::make($request->all(), [
    'person.*.email' => 'email|unique:users',
    'person.*.first_name' => 'required_with:person.*.last_name',
]);
```

Da mesma forma, você pode usar o caractere `*` ao especificar suas mensagens de validação em seus arquivos de idioma, tornando-se fácil para usar uma única mensagem de validação para campos baseados em matrizes:

```php
'custom' => [
    'person.*.email' => [
        'unique' => 'Each person must have a unique e-mail address',
    ]
],
```



## Regras de validação personalizadas

### Usando Objetos de Regra

O Laravel fornece uma variedade de regras de validação úteis; no entanto, você pode querer especificar algumas. Um método de registrar regras de validação personalizadas é usar objetos de regras. Para gerar um novo objeto de regra, você pode usar o comando `make:rule` do Artisan. Vamos usar esse comando para gerar uma regra que verifica se uma seqüência de caracteres é maiúscula. O Laravel colocará a nova regra no diretório `app/Rules`:

```sh
php artisan make:rule Uppercase 
```

Uma vez que a regra foi criada, estamos prontos para definir seu comportamento. Um objeto de regra contém dois métodos: `passes` e `message` . O método `passes` recebe o valor e o nome do atributo e deve retornar `true` ou `false` dependendo se o valor do atributo é válido ou não. O método `message` deve retornar a mensagem de erro de validação que deve ser usada quando a validação falhar:

```php
<?php

namespace App\Rules;

use Illuminate\Contracts\Validation\Rule;

class Uppercase implements Rule
{
    /**
     * Determine if the validation rule passes.
     *
     * @param  string  $attribute
     * @param  mixed  $value
     * @return bool
     */
    public function passes($attribute, $value)
    {
        return strtoupper($value) === $value;
    }

    /**
     * Get the validation error message.
     *
     * @return string
     */
    public function message()
    {
        return 'The :attribute must be uppercase.';
    }
}
```

Claro, você pode chamar o helper `trans` no seu método `message` se você quiser retornar uma mensagem de erro de seus arquivos de tradução:

```php
/**
 * Get the validation error message.
 *
 * @return string
 */
public function message()
{
    return trans('validation.uppercase');
}
```

Uma vez que a regra foi definida, você pode anexá-la a um validador passando uma instância do objeto de regra com suas outras regras de validação:

```php
use App\Rules\Uppercase;

$request->validate([
    'name' => ['required', new Uppercase],
]);
```

### Usando extensões

Outro método de registro de regras de validação personalizadas é o uso do método `extend` na façade `Validator`. Vamos usar esse método dentro de um provedor de serviços para registrar uma regra de validação personalizada:

```php
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use Illuminate\Support\Facades\Validator;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Bootstrap any application services.
     *
     * @return void
     */
    public function boot()
    {
        Validator::extend('foo', function ($attribute, $value, $parameters, $validator) {
            return $value == 'foo';
        });
    }

    /**
     * Register the service provider.
     *
     * @return void
     */
    public function register()
    {
        //
    }
}
```

O Closure do validador personalizado recebe quatro argumentos: o nome do `$attribute` que está sendo validado, o `$value` do atributo, uma matriz `$parameters` passados para a regra e a instância do `Validator`.

Você também pode passar uma classe e método para o método `extend` vez de um Closure:

```php
Validator::extend('foo', 'FooValidator@validate'); 
```

#### Definindo a mensagem de erro

Você também precisará definir uma mensagem de erro para sua regra personalizada. Você pode fazer isso usando uma matriz de mensagem personalizada inline ou adicionando uma entrada no arquivo de linguagem de validação. Esta mensagem deve ser colocada no primeiro nível da matriz, não dentro da matriz `custom` , que é apenas para mensagens de erro específicas de atributos:

```php
"foo" => "Your input was invalid!",

"accepted" => "The :attribute must be accepted.",

// The rest of the validation error messages...
```

Ao criar uma regra de validação personalizada, às vezes você precisa definir place-holders personalizadas para mensagens de erro. Você pode fazê-lo através da criação de um validador personalizado como descrito acima, em seguida, fazer uma chamada para o metódo `replacer`na façade `Validator`. Você pode fazer isso dentro do método `boot` de um provedor de serviços:

```php
/**
 * Bootstrap any application services.
 *
 * @return void
 */
public function boot()
{
    Validator::extend(...);

    Validator::replacer('foo', function ($message, $attribute, $rule, $parameters) {
        return str_replace(...);
    });
}
```

#### Extensões implícitas

Por padrão, quando um atributo que está sendo validado não está presente ou contém um valor vazio, conforme definido pela regra `required`, regras de validação normais, incluindo extensões personalizadas, não são executadas. Por exemplo, a regra `unique` não será executada em um valor `null`:

```php
$rules = ['name' => 'unique'];

$input = ['name' => null];

Validator::make($input, $rules)->passes(); // true
```

Para que uma regra seja executada, mesmo quando um atributo está vazio, a regra deve implicar que o atributo é obrigatório. Para criar uma extensão "implícita", use o método `Validator::extendImplicit()`:

```php
Validator::extendImplicit('foo', function ($attribute, $value, $parameters, $validator) {
    return $value == 'foo';
});
```

> Uma extensão "implícita" únicamente implica que o atributo é obrigatório. Se ele realmente invalida um atributo em falta ou vazia a você.
>